# 马尔科夫链，稳态
# 其实下面的代码A改为A.T可能数据更好处理一点，比如加一个状态的话，A需要增加一列，而A.T只需要增加一行
import numpy as np

# Ax=x，感觉稳态的分量x，就是A的特征向量，且对应的特征值为1
# 这不就是说，凡是有唯一稳态的矩阵，必存在特征值1
# 实际有唯一稳态的矩阵要求强得多：不可约，非周期，正常返
A = np.matrix([[0.7, 0.3, 0.2],
               [0.2, 0.5, 0.4],
               [0.1, 0.2, 0.4]])

# B矩阵每一列都相同，它代表的意义是，无论初始处于哪个状态，在经过多步过程后，
# 到达状态1的概率都是46808511，到达状态2的概率是0.34042553，到达状态3的概率是0.19148936
# 与之相对，A矩阵表示，经过单步过程后所处的状态与之前所在状态有关
B = np.matrix([[0.46808511, 0.46808511, 0.46808511],
               [0.34042553, 0.34042553, 0.34042553],
               [0.19148936, 0.19148936, 0.19148936]])

# 想想为什么下面3个结果都相等？可将B视为A连乘的极限，就很容易理解了
print(A @ B)
print(B @ A)

print(B @ B)

print(B.T[0] @ A)

evalue, evector = np.linalg.eig(A)
print(evalue)
# print(evector)
print(evector / evector[:, 0].sum(axis=0))  # 果然，特征值1对应的特征向量归一化之后，就是稳态的分量x

C = np.matrix([[1, 1, 1],
               [0, 1, 1],
               [0, 0, 1]])
print(C @ B)
print(B @ C)

D = np.matrix([[0.1, 0.3],
               [0.2, 0.3],
               [0.7, 0.4]])
print(B @ D)

print(A ** 100)
